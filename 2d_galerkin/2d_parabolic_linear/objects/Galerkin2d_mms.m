classdef Galerkin2d_mms
% GALERKIN2D_MMS(DOM,AUXFUN,MMSPARAMS,NAMEVALUEARGS) runs an MMS
% test on a parabolic PDE
%
% author: Tyler Fara				Date: August 29, 2024
%-----------------------------------------------------------------------------%
%
% required arguments
%	dom			Domain2d object
%	time		TimeStepping object
%	auxfun		AuxFunctions2d object
%	mmsparams	MMSParams object
%
% optional arguments
%	errType
%
% properties
%	NEEDS TO BE FILLED IN
%
%-----------------------------------------------------------------------------%
%
% notes
%	(1) The GalerkinParabolic2d_mms class is a superclass that specifies how
%	data for an MMS test should be stored, and contains most of the methods
%	necessary to run an MMS test. However, an instance of the
%	GalerkinParabolic2d_mms class cannot, itself, run an MMS test. Rather, the
%	GalerkinParabolic2d_mms superclass is designed as a template for
%	subclasses, instances of which can run MMS tests. For example, the
%	GalerkinHeat2d_mms class is a subclass of GalerkinParabolic2d_mms and an
%	instance of the GalerkinHeat2d_mms class can run MMS tests. 
%
%	To explain in more detail: The GalerkinParabolic2d_mms class contains the
%	method self.solveManufacturedProblems which calls the method self.solve.
%	However, in the GalerkinParabolic2d_mms class, the self.solve method is
%	blank; it is a placeholder method. By contrast, in the GalerkinHeat2d_mms
%	subclass, the self.solve method is redefined to solve the problem by
%	creating an instance of the GalerkinHeat2d_solver class, which takes the
%	input data generated by GalerkinParabolic2_mms and solves the problem in
%	the appropriate way for the heat equation. Thus, when an MMS test is to be
%	run on a new type of parabolic problem, one need only write a solver for
%	that problem, and create a new subclass of the GalerkinParabolic2d_mms
%	class, this new subclass calling the new solver in its self.solve method. 
%
%	(2) The input auxfun is an instance of the AuxFunctions2d object, which is
%	itself another superclass, instances of which are also not able to actually
%	run MMS tests. Rather, one must use derived classes to actually run MMS
%	tests. This is because instances of subclasses of AuxFunctions2d know how
%	to manufacture data for the MMS test. 
%
%	Again, to explain in more detail: The AuxFunctions2d class knows how to
%	manufacture flux q and divergence of flux divq from the true solution uTrue
%	and the conductivity k. For the heat equation, this is all that is needed
%	to manufacture the RHS. However, for the reaction diffusion equation or the
%	for the pennes bioheat transfer equation, more information and a different
%	procedure is used to manufacture the RHS. Hence, AuxFunctions2d_heat and
%	AuxFunctions2d_pennes, each subclasses of AuxFunctions2d, will manufacture
%	different RHS's using different procedures, those procedures being adapted
%	appropriately for the respective problem. 
%
%	To continue the example, when instantiating GalerkinHeat2d_mms, one must
%	pass an AuxFunctions2d_heat object. When instantiating a
%	GalerkinPennes2d_mms object, one must pass an AuxFunctions2d_pennes object.
%	If the instance of the AuxFunctions2d subclass is not appropriate for the
%	instance of the GalerkinParabolic2d_mms subclass, an error will occur. 
%
%	(3) By contrast, boundary conditions for all parabolic type problems are
%	manufactured in the same way. Thus, the GalerkinParabolic2d_mms class
%	itself directs the manufacturing of boundary conditions. If,
%	hypothetically, a problem arose where boundary conditions did need to be
%	manufactured in a different way, then a subclass of GalerkinParabolic2d_mms
%	could be written wherein the self.manufactureBoundaryConditions method
%	could be redefined. In MATLAB, when a superclass constructor is called,
%	that constructor will use methods that are redefined in the subclass; so
%	the superclass constructor would use the redefined
%	self.manufactureBoundaryConditions method. 

	properties
		problems
		auxFunctions
		domain
		mmsParams
		errType
		errors
		ratios
		orders
	end

	methods
		function self = Galerkin2d_mms(dom,auxfun,mmsparams,NameValueArgs)

			% store inputs
			self.auxFunctions = auxfun;
			self.errType = NameValueArgs.errType;
			self.mmsParams = mmsparams;

			% manufacture boundary conditions
			fprintf(' Setting BCs:'), tic
			self.domain = self.manufactureBoundaryConditions(dom,auxfun);
			executionTime = toc;
			fprintf(' %f s\n',executionTime)

			% if not in demo-mode, run MMS test
			if self.mmsParams.demo == 0
				self.problems = self.solveManufacturedProblems;
				[self.errors,self.ratios,self.orders] = self.computeErrors;

			% else, if in demo-mode, only run one trial
			else
				self.problems = self.solveManufacturedProblems;
			end

		end

		function problems = solveManufacturedProblems(self)

			% unpack variables
			f     = self.auxFunctions.source2FunctionHandle;
			cofs  = self.auxFunctions.coefficients2FunctionHandles;
			uInit = self.auxFunctions.uInit2FunctionHandle;
			base  = self.mmsParams.base;
			pmin  = self.mmsParams.pmin;
			pmax  = self.mmsParams.pmax;
			tOff  = self.mmsParams.timeOffset;
			tFac  = self.mmsParams.timeFactor;

			% Solve problems for successive base^-p
			fprintf('MMS Test Begun\n')
			fprintf('Solving Problems\n')

			% run mms test
			ind = 1;
			for p = pmin:pmax
				
				tic 
				fprintf(' p = %i solved:',p)
				% successively refine mesh and time-stepping 
				dom_p  = self.domain.setMesh(p,base);
				time_p = self.timeStepping.setMesh(tFac*(p-tOff),base); %<~~ NOTE: time stepping one order higher

				% run solver on current mesh
				prob_p = self.solve(dom_p,time_p,cofs,uInit,f);

				% store results
				if self.mmsParams.demo == 0, problems{ind} = prob_p;
				else problems{1} = prob_p;
				end

				ind = ind + 1;
				executionTime = toc;
				fprintf(' %f s\n',executionTime)
			end

		end

		function prob = solve(self,dom,time,cofs,uInit,f)

			% NOTE: placeholder function. Actually handled by specific subclasses.
			...

		end

		function dom = setEdgeNormalVectors_outerBoundary(self,dom)

			% store variables
			dl = dom.dl;

			% get normal vectors
			n_lower = [0; -1];
			n_right = [1; 0];
			n_upper = [0; 1];
			n_left  = [-1; 0];

			n_vectors = [n_lower, n_right, n_upper, n_left];

			% loop over columns of decomposed geometry description matrix
			for j = 1:4;

				% for now, it is assumed the outer boundary is rectangular
				if dl(1,j) == 2

					n = n_vectors(:,mod(j-1,4)+1);

				end
				
				% store normal vector
				dom.edges(j).outwardNormal = n;

			end

		end

		function dom = setEdgeNormalVectors_inclusions(self,dom)

			% store variables
			dl = dom.dl;
			scale_eps = 1 / dom.epsilon;

			% setup symbolic functions for circle edges
			x = sym('x',[1 2],'real'); syms t;

			% if unit vectors to circle are needed, store in advance
			if sum(find(dl(1,:) == 1)) > 0
				n_lower = dom.inclusion.Q.unitNormal_lower;
				n_upper = dom.inclusion.Q.unitNormal_upper;
			end

			% loop over columns of decomposed geometry description matrix
			for j = 5:size(dl,2);

				% if edge corresponds to circle
				if dl(1,j) == 1 

					% set x-translation
					x_translate = dl(8,j);
					x_transformed = scale_eps * (x(1) - x_translate);

					% if lower edge of circle
					if mod(j,4) == 1 || mod(j,4) == 2

						n = symfun(n_lower(x_transformed,x(2)),[x t]);

					% else upper edge of circle
					else

						n = symfun(n_upper(x_transformed,x(2)),[x t]);

					end

				% if edge corresonds to a line segment	
				elseif dl(1,j) == 2

					n = dom.inclusion.Q.unitNormal(:,mod(j-1,4)+1);
					
				end
				
				% store normal vector
				dom.edges(j).outwardNormal = n;

			end
		end

		function dom = manufactureBoundaryConditions(self,dom,auxfun);

			% unpack coefficients
			x = sym('x',[1 2]); syms t;
			uTrue = self.auxFunctions.uTrue;
			q = self.auxFunctions.q;
			nEdges = dom.nEdges;

			% set edge normal vectors
			dom = self.setEdgeNormalVectors_outerBoundary(dom);
			dom = self.setEdgeNormalVectors_inclusions(dom);

			% Manufacture Dirichlet BC
			u_d = uTrue;
			u_d = matlabFunction(u_d);

			% assign boundary functions
			for i = 1:nEdges

				% assign Dirichlet BC
				if dom.edges(i).boundaryType == 'D'
					dom.edges(i).boundaryCondition = u_d;

				% assign Neumann BC
				elseif dom.edges(i).boundaryType == 'N'
					n_i = dom.edges(i).outwardNormal;
					g_i = symfun(sum(q.*n_i),[x t]);
					g_i = matlabFunction(g_i);
					dom.edges(i).boundaryCondition = g_i;

				% assign Robin BC
				elseif dom.edges(i).boundaryType == 'R'
					alpha_i = symfun(1.0,[x t]);
					n_i = dom.edges(i).outwardNormal;
					g_i = symfun(uTrue - sum(q .* n_i) / alpha_i,[x t]);
					alpha_i = matlabFunction(alpha_i);
					g_i = matlabFunction(g_i);
					dom.edges(i).boundaryCondition = {alpha_i,g_i};
				end
			end

		end

		function [errors,ratios,orders] = computeErrors(self)

			% store variables
			trials = length(self.problems);
			base = self.problems{1}.domain.base;

			% Store errors
			errors = zeros(1,trials);
			ratios = zeros(1,trials-1);
			orders = zeros(1,trials-1);

			% Compute error
			errorObj = mmsErrorComputer(self);
			errors = errorObj.errors;

			% Compute ratios and orders
			for i = 2:trials
				ratios(i-1) = errors(i-1)/errors(i);
				orders(i-1) = log(ratios(i-1)) / log(base);
			end

		end

		function v = computeOutwardNormal(self,nod1,nod2)

			x = nod2(1) - nod1(1);
			y = nod2(2) - nod1(2);
			v = [y,-x];

		end

		function ax = plot(self)

			h = zeros(1,4);
			for i = 1:4
				base = self.problems{i}.domain.base;
				p = self.problems{i}.domain.p;
				h(i) = base^-p;
			end

			loglog(h,h,'k--',h,h.^2,'k-.',h,self.errors,'r*-','LineWidth',3,'MarkerSize',18); grid on;
			title('Error of D_hf');
			legend('linear','quadratic','e(h)','location','southeast');
			f = gcf;
			f.Position = [100 100 800 * 3/4 600 * 3/4];

			ax = gca;

		end

		function fineGrid = instantiateFineGridObject(self)
	
			dom = self.problems{1}.domain;
			bc  = self.problems{1}.boundary;
			k   = self.problems{1}.conductivity;
			f   = self.problems{1}.source;

			fineGrid = poissonFD1d_finegrid(dom,bc,k,f);

		end

		function latexTable(self,fid)
			
			aType = self.problems{1}.boundary.aType;
			bType = self.problems{1}.boundary.bType;
			errors = self.errors;
			orders = self.orders;

			% Table Preamble
			fprintf(fid,'%%\n')
			fprintf(fid,'\\begin{table}[]\n')
			fprintf(fid,'\t\\centering\n')
			fprintf(fid,'\t\\begin{tabular}{c c c}\n')

			% Table title line
			fprintf(fid,'\t\\hline\n');
			fprintf(fid,'\t\t refinement & error & rate \\\\ \n');
			fprintf(fid,'\t\\hline\n');

			% Table Main Data
			fprintf(fid,'\t\t $h$ & %.4d & --     \\\\ \n',errors(1));
			for i = 1:3
				fprintf(fid,'\t\t $h^%i$ & %.4d & %.4f \\\\ \n',i+1,errors(i+1),orders(i));
			end
			fprintf(fid,'\t\\hline\n')

			% Table Footer
			fprintf(fid,'\t\\end{tabular}\n')
			fprintf(fid,'\t\\caption{\\textbf{Problem :} MMS, Boundary: %c and %c}\n',aType,bType)
			fprintf(fid,'\t\\label{tab:1-}\n')
			fprintf(fid,'\\end{table}\n')
			fprintf(fid,'%%\n')
		end

		
		function plotTrueSolution(self)

			nProb = length(self.problems);
			prob = self.problems{nProb};
			uTrue = self.uTrue;
			uTrue = matlabFunction(uTrue);

			% plot final timestep unless otherwise specified
			if nargin < 2, timestep = prob.time.N_t; end
			t = timestep * prob.time.dt;

			% store domain information
			coordinates = prob.domain.Mesh.Nodes';
			elements3 = prob.domain.Mesh.Elements';
			elements4 = [];

			% get solution at final time step
			U = uTrue(coordinates(:,1),coordinates(:,2),t * ones(size(coordinates,1),1))

			% plot data
			trisurf(elements3,coordinates(:,1),coordinates(:,2),U', ...
				'facecolor','interp')
			hold on
			trisurf(elements4,coordinates(:,1),coordinates(:,2),U', ...
				'facecolor','interp')
			hold off

			% format plot
			view(10,40);
			title('Solution of the Problem')
		end

	end

end

