classdef PuncturedDomain2d < Domain2d & fegeometry
%PuncturedMesh is a punctured mesh for 2d Galerkin FEM
%	
% mesh = PuncturedMesh(xBounds,yBounds,h,N_x,N_y) generates a quasiuniform
%	triangulated mesh on a rectangle of size xBounds by yBounds with triangles
%	of max diameter h.
%
% Author: Tyler Fara					Date: April 19, 2024
%
%-----------------------------------------------------------------------------%
% Properties
%	xBounds		double (vector), format [x_0,x_1] 
%	yBounds		double (vector), format [y_0,y_1]
%	nInclusions	int (vector), format [N_x, N_y, N_x * N_y]
%	h			double, max triangle diameter
%	mesh		fegeometry object
%
%-----------------------------------------------------------------------------%
% Methods
%	PuncturedMesh(xBounds,yBounds,h,N_x,N_y)
%	Constructor for PuncturedMesh object
% 		inputs
%			xBounds		double (vector), format [x_0,x_1] 
%			yBounds		double (vector), format [y_0,y_1]
%			h			double, max triangle diameter
%			N_x			int, number of inclusions along x-dimension
%			N_y			int, number of inclusions along y-dimension
%		outputs
%			mesh		PuncturedMesh object
%
%	plot(self)
%	Plots mesh
%
%-----------------------------------------------------------------------------%
% Notes
%	(1) The procedure used to generate the mesh:
%		1. Describe domain geometry using constructive solid geometry (CSG)
%		2. Decompose that object using minimal regions
%		3. Create an fegeometry object using that deconstruction 
%		4. Call the fegeometry method called generateMesh to generate the mesh
%
% 	(2) CSG uses simple shapes to build complex shapes through the operations
% 	of set addition, subtraction, and intersection. To implement CSG, matlab
% 	uses objects called a geometry description matrix, a set formula, and a
% 	name-space matrix. The geometry description matrix gd stores numeric
% 	information about the shapes (more description below). The set formula
% 	character array sf stores information about how the shapes interact (more
% 	description below). The name-space matrix ns connects the numeric data in
% 	gd to the interaction data in sf. 
%
%	(3) For the geometry description matrix gd: In this case, the only
% 	shape I will need is rectangles (though, theoretically I could model
% 	inclusions using circles). I specify the rectangles as vectors, where the
% 	convention is: 
%
%		Row 1: 		3, the convention for a rectangle
%		Row 2: 		4, specifies 4 sides
%		Row 3-6:	x coordinates, going counterclockwise from lower left
%		Row 7-10:	y coordinates, going counterclockwise from lower left
%
% 	These vectors become the columns of the geometry description matrix gd. If
% 	I am using N inclusions, then gd will be a 10 x (N+1) matrix. That's 10
% 	rows for the 10 entries needed to specify each rectangle, and N+1 columns,
% 	i.e. N columns for the N inclusions, and 1 column for the outer boundary
% 	itself. 
%
% 	(3) For the set formula sf: This is a character array describing the set
% 	operations that will be used to construct the final geometry. In this case,
% 	we only need set minus operations, which are encoded by minus signs, and
% 	which are used to indicate that the inclusions should be subtracted from
% 	the original domain.
%
% 	(4) For the name-space matrix ns: Each column of ns represents the name of
% 	the object represented by the data in the corresponding column of the gd
% 	matrix. 
%
%	(5) For example, for a domain with one inclusion, gd will be a 10 x 2
%	matrix: one column for the domain and one column for the inclusion. The sf
%	will be sf = 'BD-P1'. The ns will be:
%			
%			ns = [B P;
%				  D 1];
%
%	where the first column contains the name 'BD' and tells matlab that the
%	data in the first column of gd is 'BD', the second column contains the name
%	'P1', and tells matlab that the second column of gd is 'P1', and that way,
%	from the set formula sf = 'BD-P1', matlab knows to subtract the object
%	represented by the second column of gd from the object represented by the
%	first column of gd. 
%
%	(6) For now, inclusions are generated by creating an array of equally
%	spaced endpoints, which are used to populate gd. For example, for some N_x,
%
%			xVert = linspace(xBounds(1),xBounds(2),2*N_x+2);
%			xVert = xVert(2:2*N_x+1);
%
%	is used to specify endpoints for the inclusions (the second line throws
%	away the nodes that correspond to the boundary of the domain. Certainly
%	we'd like to be able to set the size of the inclusions relative to the rest
%	of the domain. So this will need to change at some point. 
%------------------------------------------------------------------------------%
% METHODS (STATIC)
% vert = boundsToRectangleVertices(x,y)
% Converts bounds x and y to vertices of a rectangular region
%	Vertices are arranged as row vectors in a 4x2 matrix with:
%
%		Row 1: Southwest corner
%		Row 2: Southeast corner
%		Row 3: Northeast corner
%		Row 4: Northwest corner
%	
%	Inputs:
%		x		double (vector), x = [x_1 x_2] the lower and upper x bounds
%		y		double (vector), y = [y_1 y_2] the lower and upper y bounds
%
%	Outputs:
%		vert	double (matrix), vert = [x_1 y_1; x_2 y_1; etc.]
%
%
% col = vertToGeometryDescriptionColumn(vert)
% Converts a matrix of vertices to a column of a geometry description matrix
% 	representing a rectangular region.
%
%	For a region bounded by x = [x_1 x_2], y = [y_1 y_2], vert is of the form
%
%		vert = [x_1 y_1; x_2 y_1; x_2 y_2; x_1 y_1]
%
%	i.e. each row represents a vertex, and the rows cycle through vertices
%	counterclockwise, starting from the southwest.
%
%
% col = boundsToGeometryDescriptionColumn(x,y)
% Converts bounds x and y to a column of a geometry description matrix
%	 representing a rectangular region.
%
%	If x = [x_1 x_2], y = [y_1 y_2] then the coresponding column is
%
%		gd_col = [3 4 x_1 x_2 x_2 x_1 y_1 y_1 y_2 y_2]
%
%	where 3 represents a rectangle, 4 represents that a rectangle has four
%	sides, and the vertices are arranged by cycling through the vertices
%	counterclockwise starting from the southwest, listing the x-coordinates
%	then the y-coordinates.
%
%	Inputs:
%		x		double (vector), x = [x_1 x_2] the lower and upper x bounds
%		y		double (vector), y = [y_1 y_2] the lower and upper y bounds
%
%-----------------------------------------------------------------------------%


	properties
		inclusionModule
		inclusions
		nInclusions
	end

	methods
		function self = PuncturedDomain2d(x,y,N_x,N_y,incMod)

			% call Domain2d superclass constructor
			self@Domain2d(x,y);

			% generate decomposed geometry matrix
			if nargin == 5
				gd = incMod.getGeometryDescriptionMatrix(x,y,N_x,N_y);
			else
				gd = PuncturedDomain2d.getGeometryDescriptionMatrix(x,y,N_x,N_y);
			end
			ns = PuncturedDomain2d.getNameSpace(N_x,N_y);
			sf = PuncturedDomain2d.getSetFunction(N_x,N_y);
			g = decsg(gd,sf,ns);

			% call fegeometry superclass constructor
			self@fegeometry(g);

			% compute properties
			self.nInclusions = N_x * N_y;
			self.geometryMatrix = gd;

			% generate and store inclusions
			if nargin == 5
				self.inclusionModule = incMod;
			end
			self.inclusions = self.generateInclusions();

			% generate and store edges
			self.edges = self.setEdgeGeometry;

		end
	end

	methods
		function inc = generateInclusions(self);
			
			% store variables
			gd = self.geometryMatrix;
			nInc = self.nInclusions;

			% generate rectangular inclusions
			inc = [];
			for i = 2:nInc+1
				inc_i = RectangularInclusion2d(gd(:,i));
				inc = [inc inc_i];
			end

		end

		function edges = setEdgeGeometry_C(self)

			% store variables
			gd = self.geometryMatrix;

			% loop over columns of geometry description matrix
			edges = [];
			for j = 1:size(gd,2);

				% get vertices
				vert = zeros(4,2);
				for i = 1:4
					vert(i,1) = gd(i+2,j);
					vert(i,2) = gd(i+6,j);
				end
				vert(5,:) = vert(1,:);

				% get midpoints
				for i = 1:4
					mdpt(i,:) = [(vert(i,1) + vert(i+1,1))/2, (vert(i,2) + vert(i+1,2))/2];
				end

				% get edge IDs
				for i = 1:4
					edge_id(i) = self.nearestEdge(mdpt(i,:));
				end

				% get normal vectors
				% if j == 1, normal vectors are for outer boundary
				n = [0 -1; 1 0; 0 1; -1 0];
				if j == 1
					...

				% else, normal vectors are for inclusion, so reverse their direction
				else
					n = -n;
				end

				% set edges
				for i = 1:4
					edge_i = BoundaryEdge2d(vert(i,:),vert(i+1,:),n(i,:));
					edge_i.ID = edge_id(i);
					edges = [edges edge_i];
				end

			end

		end

		function edges = setEdgeGeometry(self)
		% NOTE: On 8/13/24, I vectorized the procedure by which edge_ids are
		% calculated. This caused a greater than 10x speedup in the wall-clock
		% time for this function. I have retained the loop that sets the edges
		% because that loop is significantly less time consuming.
		% However, even more speedup might be possible if that loop is
		% also vectorized. 

			% store variables
			gd = self.geometryMatrix;
			coord = self.geometryMatrix(3:10,:);

			% find midpoints
			permuteRows = [[2 3 4 1], [2 3 4 1] + 4];
			midpts   = (coord + coord(permuteRows,:)) / 2;
			midpts_x = reshape(midpts([1:4],:),[],1);
			midpts_y = reshape(midpts([1:4]+4,:),[],1);

			% use midpoints to get edge ids
			edge_ids = self.nearestEdge([midpts_x,midpts_y]);
			edge_ids = reshape(edge_ids,4,[]);

			% loop over columns of geometry description matrix
			edges = [];
			for j = 1:size(gd,2);

				edge_id = edge_ids(:,j)';

				% get normal vectors
				% if j == 1, normal vectors are for outer boundary
				n = [0 -1; 1 0; 0 1; -1 0];
				if j == 1
					...

				% else, normal vectors are for inclusion, so reverse their direction
				else
					n = -n;
				end

				% set edges
				vert = [gd([1:4]+2,j),gd([1:4]+6,j)];
				vert(5,:) = vert(1,:);
				for i = 1:4
					edge_i = BoundaryEdge2d(vert(i,:),vert(i+1,:),n(i,:));
					edge_i.ID = edge_id(i);
					edges = [edges edge_i];
				end

			end
		end

		function self = setEdgeBCTypes(self,boundary)

			edges = self.edges;

			% set outer boundary types
			for i = 1:4
				edges(i).boundaryType = boundary.boundaryTypes{i};
			end

			% set boundary types on inclusions
			incBCTypes = boundary.boundaryTypesInclusions;
			if sum(size(incBCTypes)) == 2
				for i = 5:self.NumEdges
					edges(i).boundaryType = incBCTypes;
				end
			else
				for i = 1:self.nInclusions, for j = 1:4
					edges(4*i + j).boundaryType = incBCTypes(i,j);
				end, end
			end

			self.edges = edges;

		end

		function self = setEdgeBCConditions(self,boundary)

			edges = self.edges;

			% set outer boundary types
			for i = 1:4
				edges(i).boundaryCondition = boundary.boundaryConditions{i};
			end

			% set boundary types on inclusions
			incBCCond = boundary.boundaryConditionsInclusions;
			if sum(size(incBCCond)) == 2 || sum(size(incBCCond)) == 3 
				for i = 5:self.NumEdges
					edges(i).boundaryCondition = incBCCond;
				end
			else
				for i = 1:self.nInclusions, for j = 1:4
					edges(4*i + j).boundaryCondition = incBCCond(i,j);
				end, end
			end

			self.edges = edges;

		end
	end

	methods (Static)

		function vert = boundsToVertices(x,y)
			
			vert = [x(1) y(1); x(2) y(1); x(2) y(2); x(1) y(2)];

		end
		
		function col = vertToGeometryDescriptionColumn(vert)
			
			col = [3,4,vert(:,1)',vert(:,2)']';

		end

		function col = boundsToGeometryDescriptionColumn(x,y)

			vert = PuncturedDomain2d.boundsToVertices(x,y);
			col  = PuncturedDomain2d.vertToGeometryDescriptionColumn(vert);
		
		end
	
		
		function gd = getGeometryDescriptionMatrix(xBounds,yBounds,N_x,N_y)

			% initialize storage
			gd = zeros(10,N_x*N_y+1);

			% put boundary rectangle in column 1 of gd
			gd(:,1) = PuncturedDomain2d.boundsToGeometryDescriptionColumn(xBounds,yBounds);

			% if nonzero number of inclusions
			if (N_x ~= 0) && (N_y ~= 0)

				% get x and y coordinates of inclusions
				xVert = linspace(xBounds(1),xBounds(2),2*N_x+2);
				yVert = linspace(yBounds(1),yBounds(2),2*N_y+2);
				xVert = xVert(2:2*N_x+1);
				yVert = yVert(2:2*N_y+1);

				% put inclusions in remaining columns of gd
				for i = 0:N_y-1, for j = 0:N_x-1

					% current column number
					col = i*N_x + j + 2;

					% bounds for inclusion
					xPunc = [xVert(2*j+1) xVert(2*j+2)];
					yPunc = [yVert(2*i+1) yVert(2*i+2)];

					% add column to geometry description matrix
					gd(:,col) = PuncturedDomain2d.boundsToGeometryDescriptionColumn(xPunc,yPunc);

				end, end
			end
		end

		function ns = getNameSpace(N_x,N_y)

			% if nonzero number of inclusions
			if (N_x ~= 0) && (N_y ~= 0)

				% create ns array
				ns = char('BD');
				for i = 1:N_x*N_y
					punc = char("P" + string(i));
					ns = char(ns,punc);
				end
				ns = ns';

			% else create unpunctured rectangular domain
			else
				ns = char('BD');
				ns = ns';
			end

		end

		function sf = getSetFunction(N_x,N_y)

			% if nonzero number of inclusions
			if (N_x ~= 0) && (N_y ~= 0)

				% create sf
				sf = 'BD-(P1';
				for i = 2:N_x*N_y
					sf = strcat(sf,'+P',int2str(i));
				end
				sf = strcat(sf,')');

			% else create unpunctured rectangular domain
			else
				sf = 'BD';
			end

		end
	end

end
