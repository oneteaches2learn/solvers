classdef GalerkinMMS2d
% GALERKIN2D_MMS(DOM,AUXFUN,MMSPARAMS,NAMEVALUEARGS) runs an MMS
% test on a parabolic PDE
%
% author: Tyler Fara				Date: August 29, 2024
%-----------------------------------------------------------------------------%
%
% required arguments
%	dom			Domain2d object
%	time		TimeStepping object
%	auxfun		AuxFunctions2d object
%	mmsparams	MMSParams object
%
% optional arguments
%	errType
%
% properties
%	NEEDS TO BE FILLED IN
%
%-----------------------------------------------------------------------------%
%
% notes
%	(1) The GalerkinParabolic2d_mms class is a superclass that specifies how
%	data for an MMS test should be stored, and contains most of the methods
%	necessary to run an MMS test. However, an instance of the
%	GalerkinParabolic2d_mms class cannot, itself, run an MMS test. Rather, the
%	GalerkinParabolic2d_mms superclass is designed as a template for
%	subclasses, instances of which can run MMS tests. For example, the
%	GalerkinHeat2d_mms class is a subclass of GalerkinParabolic2d_mms and an
%	instance of the GalerkinHeat2d_mms class can run MMS tests. 
%
%	To explain in more detail: The GalerkinParabolic2d_mms class contains the
%	method self.solveManufacturedProblems which calls the method self.solve.
%	However, in the GalerkinParabolic2d_mms class, the self.solve method is
%	blank; it is a placeholder method. By contrast, in the GalerkinHeat2d_mms
%	subclass, the self.solve method is redefined to solve the problem by
%	creating an instance of the GalerkinHeat2d_solver class, which takes the
%	input data generated by GalerkinParabolic2_mms and solves the problem in
%	the appropriate way for the heat equation. Thus, when an MMS test is to be
%	run on a new type of parabolic problem, one need only write a solver for
%	that problem, and create a new subclass of the GalerkinParabolic2d_mms
%	class, this new subclass calling the new solver in its self.solve method. 
%
%	(2) The input auxfun is an instance of the AuxFunctions2d object, which is
%	itself another superclass, instances of which are also not able to actually
%	run MMS tests. Rather, one must use derived classes to actually run MMS
%	tests. This is because instances of subclasses of AuxFunctions2d know how
%	to manufacture data for the MMS test. 
%
%	Again, to explain in more detail: The AuxFunctions2d class knows how to
%	manufacture flux q and divergence of flux divq from the true solution uTrue
%	and the conductivity k. For the heat equation, this is all that is needed
%	to manufacture the RHS. However, for the reaction diffusion equation or the
%	for the pennes bioheat transfer equation, more information and a different
%	procedure is used to manufacture the RHS. Hence, AuxFunctions2d_heat and
%	AuxFunctions2d_pennes, each subclasses of AuxFunctions2d, will manufacture
%	different RHS's using different procedures, those procedures being adapted
%	appropriately for the respective problem. 
%
%	To continue the example, when instantiating GalerkinHeat2d_mms, one must
%	pass an AuxFunctions2d_heat object. When instantiating a
%	GalerkinPennes2d_mms object, one must pass an AuxFunctions2d_pennes object.
%	If the instance of the AuxFunctions2d subclass is not appropriate for the
%	instance of the GalerkinParabolic2d_mms subclass, an error will occur. 
%
%	(3) By contrast, boundary conditions for all parabolic type problems are
%	manufactured in the same way. Thus, the GalerkinParabolic2d_mms class
%	itself directs the manufacturing of boundary conditions. If,
%	hypothetically, a problem arose where boundary conditions did need to be
%	manufactured in a different way, then a subclass of GalerkinParabolic2d_mms
%	could be written wherein the self.manufactureBoundaryConditions method
%	could be redefined. In MATLAB, when a superclass constructor is called,
%	that constructor will use methods that are redefined in the subclass; so
%	the superclass constructor would use the redefined
%	self.manufactureBoundaryConditions method. 

	properties
		problems
		auxFunctions
		domain
		mmsParams
		errType
		errors
		ratios
		orders
	end

	methods
		% CONSTRUCTOR 
		function self = GalerkinMMS2d(dom,auxfun,mmsparams,NameValueArgs)

			% store inputs
			self.auxFunctions = auxfun;
			self.errType = NameValueArgs.errType;
			self.mmsParams = mmsparams;
			try, time = NameValueArgs.time; end

			% manufacture boundary conditions
			fprintf(' Setting BCs:'), tic
			if isa(self,'GalerkinMMS2d_parabolic')
				self.domain = self.manufactureBoundaryConditions(dom,auxfun,time);
			else
				self.domain = self.manufactureBoundaryConditions(dom,auxfun);
			end
			executionTime = toc;
			fprintf(' %f s\n',executionTime)

			% if not in demo-mode, run MMS test
			if self.mmsParams.demo == 0

				% solve problems
				if isa(self,'GalerkinMMS2d_parabolic')
					self.problems = self.solveManufacturedProblems(time);
				else
					self.problems = self.solveManufacturedProblems;
				end

				% compute errors
				[self.errors,self.ratios,self.orders] = self.computeErrors;

			% else, if in demo-mode, only run one trial
			else
				if isa(self,'GalerkinMMS2d_parabolic')
					self.problems = self.solveManufacturedProblems(time);
				else
					self.problems = self.solveManufacturedProblems;
				end
			end

		end


		% UTILITY FUNCTIONS
		function problems = solveManufacturedProblems(self,varargin)

			% unpack variables
			cofs = self.auxFunctions.functionHandles;
			base = self.mmsParams.base;
			pmin = self.mmsParams.pmin;
			pmax = self.mmsParams.pmax;
			tOff = self.mmsParams.timeOffset;
			tFac = self.mmsParams.timeFactor;
			region = self.mmsParams.effectiveRegion;

			% run mms test
			fprintf('MMS Test Begun\n')
			fprintf('Solving Problems\n')
			ind = 1;
			for p = pmin:pmax
				
				% successively refine mese
				fprintf(' p = %i solved:',p); tic;

				dom_p = self.configureDomain(p); 
				prob_p = self.solve(dom_p,cofs);

				% store results
				if self.mmsParams.demo == 0, problems{ind} = prob_p;
				else problems{1} = prob_p;
				end

				% prepare next trial
				ind = ind + 1;
				executionTime = toc;
				fprintf(' %f s\n',executionTime)

			end
		end

		function dom_p = configureDomain(self,p)

			% unpack variables
			cofs = self.auxFunctions.functionHandles;
			base = self.mmsParams.base;
			pmin = self.mmsParams.pmin;
			pmax = self.mmsParams.pmax;
			tOff = self.mmsParams.timeOffset;
			tFac = self.mmsParams.timeFactor;
			region = self.mmsParams.effectiveRegion;


			dom_p = self.domain;

			%dom_p = dom_p.setMesh(p,base);
			%dom_p = dom_p.setMesh(p,base,...
			%		meshInclusions=self.mmsParams.meshInclusions,...
			%		effectiveRegion=self.mmsParams.effectiveRegion);
			dom_p = dom_p.setMesh(p,base);

			% assign boundary nodes to edges
			dom_p = dom_p.setBoundaryNodes;

			% set time grid
			if isa(self,'GalerkinMMS2d_parabolic')
				dom_p.time = dom_p.time.setMesh(tFac*(p-tOff),base);
			end
			%{
			if strcmp(region,'Omega')
				dom_p = self.domain.setMesh(p,base,...
						meshInclusions='on',effectiveRegion='all');
			else
				dom_p = self.domain.setMesh(p,base,meshInclusions='on');
			end
			dom_p = dom_p.setBoundaryNodes;
			%}

		end

		function dom = manufactureBoundaryConditions(self,dom,auxfun,varargin);

			% unpack coefficients
			uTrue = self.auxFunctions.uTrue;
			q = self.auxFunctions.q;
			nEdges = dom.boundary.nEdges;

			% set symbolic variables
			if ~isempty(dom.time)
				x = sym('x',[1 2]); syms t;
				vars = [x t];
			else
				x = sym('x',[1 2]);
				vars = x;
			end

			% set edge normal vectors
			dom = self.setEdgeNormalVectors_outerBoundary(dom);
			if isa(dom,'Domain2d_punctured')
				dom = self.setEdgeNormalVectors_inclusions(dom);
			end

			% Manufacture Dirichlet BC
			u_d = uTrue;
			u_d = matlabFunction(u_d);

			% assign boundary functions
			for i = 1:nEdges

				% assign Dirichlet BC
				if dom.boundary.edges(i).boundaryType == 'D'
					dom.boundary.edges(i).boundaryCondition = u_d;

				% assign Neumann BC
				elseif dom.boundary.edges(i).boundaryType == 'N'
					n_i = symfun(dom.boundary.edges(i).outwardNormal,vars);
					g_i = symfun(sum(q.*n_i),vars);
					g_i = matlabFunction(g_i);
					dom.boundary.edges(i).boundaryCondition = g_i;

				% assign Robin BC
				elseif dom.boundary.edges(i).boundaryType == 'R'
					alpha_i = symfun(1.0,vars);
					n_i = symfun(dom.boundary.edges(i).outwardNormal,vars);
					g_i = symfun(uTrue - sum(q .* n_i) / alpha_i,vars);
					alpha_i = matlabFunction(alpha_i);
					g_i = matlabFunction(g_i);
					dom.boundary.edges(i).boundaryCondition = {alpha_i,g_i};
				end
			end

		end

		function dom = setEdgeNormalVectors_outerBoundary(self,dom)

			% store variables
			dl = dom.boundary.dl;

			% get normal vectors
			n_lower = [0; -1];
			n_right = [1; 0];
			n_upper = [0; 1];
			n_left  = [-1; 0];

			n_vectors = [n_lower, n_right, n_upper, n_left];

			% loop over columns of decomposed geometry description matrix
			for j = 1:4;

				% for now, it is assumed the outer boundary is rectangular
				if dl(1,j) == 2

					n = n_vectors(:,mod(j-1,4)+1);

				end
				
				% store normal vector
				dom.boundary.edges(j).outwardNormal = n;

			end

		end

		function dom = setEdgeNormalVectors_inclusions(self,dom)

			% store variables
			dl = dom.boundary.dl;
			scale_eps = 1 / dom.epsilon;

			% setup symbolic functions for circle edges
			x = sym('x',[1 2],'real');

			% if unit vectors to circle are needed, store in advance
			if sum(find(dl(1,:) == 1)) > 0
				n_lower = dom.inclusion.Q.unitNormal_lower;
				n_upper = dom.inclusion.Q.unitNormal_upper;
			end

			% store numbers of geometry edges
			nOuterEdges_dl = size(dom.boundary.dl_outer,2);
			nOuterEdges_dom = 4;
			nyLines = size(dom.boundary.dl_yLines,2);
			nIncEdges = size(dom.boundary.dl_inclusions,2);

			% store dl cols that correspond to inclusion edges
			dl_cols = dom.boundary.dl_IDs.inclusions;

			% loop over columns of decomposed geometry description matrix
			for i = 1:nIncEdges

				dl_col = nOuterEdges_dl + nyLines + i
				incEdgeNum = nOuterEdges_dom + i;
				
				% if edge corresponds to circle
				if dl(1,dl_col) == 1 

					% set x-translation
					x_translate = dl(8,dl_col);
					x_transformed = scale_eps * (x(1) - x_translate);

					% if lower edge of circle
					if mod(i,4) == 1 || mod(i,4) == 2

						n = symfun(n_lower(x_transformed,x(2)),x);

					% else upper edge of circle
					else

						n = symfun(n_upper(x_transformed,x(2)),x);

					end

				% if edge corresonds to a line segment	
				elseif dl(1,dl_col) == 2

					n = dom.inclusion.Q.unitNormal(:,mod(i-1,4)+1);
					
				end
				
				% store normal vector
				dom.boundary.edges(incEdgeNum).outwardNormal = n;

			end
		end

		function [errors,ratios,orders] = computeErrors(self)

			% store variables
			trials = length(self.problems);
			base = self.problems{1}.domain.mesh.base;

			% Store errors
			errors = zeros(1,trials);
			ratios = zeros(1,trials-1);
			orders = zeros(1,trials-1);

			% Compute error
			fprintf('Computing Errors:\n')
			uTrue = self.auxFunctions.uTrue;
			for i = 1:self.mmsParams.nTrials
				fprintf(' Trial: '); tic;
				sol = self.problems{i}.solution;
				if strcmp(self.mmsParams.quadType,'threePoint')
					err = self.problems{i}.domain.L2err_threePointQuadrature_nodal(sol,uTrue);
				elseif strcmp(self.mmsParams.quadType,'centroid')
					err = self.problems{i}.domain.L2err_centroidQuadrature_nodal(sol,uTrue);
				elseif strcmp(self.mmsParams.quadType,'nodal')
					err = self.problems{i}.domain.L2err_nodalQuadrature(sol,uTrue);
				end
				errors(i) = max(err);
				executionTime = toc;
				fprintf('%f s\n',executionTime) 
			end

			% Compute ratios and orders
			for i = 2:trials
				ratios(i-1) = errors(i-1)/errors(i);
				orders(i-1) = log(ratios(i-1)) / log(base);
			end

		end


		% PLOTTERS
		function ax = plot(self)

			h = zeros(1,4);
			for i = 1:4
				base = self.problems{i}.domain.mesh.base;
				p = self.problems{i}.domain.mesh.p;
				h(i) = base^-p;
			end

			loglog(h,h,'k--',h,h.^2,'k-.',h,self.errors,'r*-','LineWidth',3,'MarkerSize',18); grid on;
			title('Error of D_hf');
			legend('linear','quadratic','e(h)','location','southeast');
			f = gcf;
			f.Position = [100 100 800 * 3/4 600 * 3/4];

			ax = gca;

		end


		% ANCILLARY FUNCTIONS
		function fineGrid = instantiateFineGridObject(self)
	
			dom = self.problems{1}.domain;
			bc  = self.problems{1}.boundary;
			k   = self.problems{1}.conductivity;
			f   = self.problems{1}.source;

			fineGrid = poissonFD1d_finegrid(dom,bc,k,f);

		end

		function plotTrueSolution(self)

			nProb = length(self.problems);
			prob = self.problems{nProb};
			uTrue = self.uTrue;
			uTrue = matlabFunction(uTrue);

			% plot final timestep unless otherwise specified
			if nargin < 2, timestep = prob.time.N_t; end
			t = timestep * prob.time.dt;

			% store domain information
			coordinates = prob.domain.Mesh.Nodes';
			elements3 = prob.domain.Mesh.Elements';
			elements4 = [];

			% get solution at final time step
			U = uTrue(coordinates(:,1),coordinates(:,2),t * ones(size(coordinates,1),1))

			% plot data
			trisurf(elements3,coordinates(:,1),coordinates(:,2),U', ...
				'facecolor','interp')
			hold on
			trisurf(elements4,coordinates(:,1),coordinates(:,2),U', ...
				'facecolor','interp')
			hold off

			% format plot
			view(10,40);
			title('Solution of the Problem')
		end

		function latexTable(self,fid)
			
			aType = self.problems{1}.boundary.aType;
			bType = self.problems{1}.boundary.bType;
			errors = self.errors;
			orders = self.orders;

			% Table Preamble
			fprintf(fid,'%%\n')
			fprintf(fid,'\\begin{table}[]\n')
			fprintf(fid,'\t\\centering\n')
			fprintf(fid,'\t\\begin{tabular}{c c c}\n')

			% Table title line
			fprintf(fid,'\t\\hline\n');
			fprintf(fid,'\t\t refinement & error & rate \\\\ \n');
			fprintf(fid,'\t\\hline\n');

			% Table Main Data
			fprintf(fid,'\t\t $h$ & %.4d & --     \\\\ \n',errors(1));
			for i = 1:3
				fprintf(fid,'\t\t $h^%i$ & %.4d & %.4f \\\\ \n',i+1,errors(i+1),orders(i));
			end
			fprintf(fid,'\t\\hline\n')

			% Table Footer
			fprintf(fid,'\t\\end{tabular}\n')
			fprintf(fid,'\t\\caption{\\textbf{Problem :} MMS, Boundary: %c and %c}\n',aType,bType)
			fprintf(fid,'\t\\label{tab:1-}\n')
			fprintf(fid,'\\end{table}\n')
			fprintf(fid,'%%\n')
		end

	end

end

