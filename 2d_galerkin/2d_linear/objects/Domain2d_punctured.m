classdef Domain2d_punctured < Domain2d
%PuncturedMesh is a punctured mesh for 2d Galerkin FEM
%	
% mesh = PuncturedMesh(xBounds,yBounds,h,N_x,N_y) generates a quasiuniform
%	triangulated mesh on a rectangle of size xBounds by yBounds with triangles
%	of max diameter h.
%
% Author: Tyler Fara					Date: April 19, 2024
%
%-----------------------------------------------------------------------------%
% Properties
%	xBounds		double (vector), format [x_0,x_1] 
%	yBounds		double (vector), format [y_0,y_1]
%	nInclusions	int (vector), format [N_x, N_y, N_x * N_y]
%	h			double, max triangle diameter
%	mesh		fegeometry object
%
%-----------------------------------------------------------------------------%
% Methods
%	PuncturedMesh(xBounds,yBounds,h,N_x,N_y)
%	Constructor for PuncturedMesh object
% 		inputs
%			xBounds		double (vector), format [x_0,x_1] 
%			yBounds		double (vector), format [y_0,y_1]
%			h			double, max triangle diameter
%			N_x			int, number of inclusions along x-dimension
%			N_y			int, number of inclusions along y-dimension
%		outputs
%			mesh		PuncturedMesh object
%
%	plot(self)
%	Plots mesh
%
%-----------------------------------------------------------------------------%
% Notes
%	(1) The procedure used to generate the mesh:
%		1. Describe domain geometry using constructive solid geometry (CSG)
%		2. Decompose that object using minimal regions
%		3. Create an fegeometry object using that deconstruction 
%		4. Call the fegeometry method called generateMesh to generate the mesh
%
% 	(2) CSG uses simple shapes to build complex shapes through the operations
% 	of set addition, subtraction, and intersection. To implement CSG, matlab
% 	uses objects called a geometry description matrix, a set formula, and a
% 	name-space matrix. The geometry description matrix gd stores numeric
% 	information about the shapes (more description below). The set formula
% 	character array sf stores information about how the shapes interact (more
% 	description below). The name-space matrix ns connects the numeric data in
% 	gd to the interaction data in sf. 
%
%	(3) For the geometry description matrix gd: In this case, the only
% 	shape I will need is rectangles (though, theoretically I could model
% 	inclusions using circles). I specify the rectangles as vectors, where the
% 	convention is: 
%
%		Row 1: 		3, the convention for a rectangle
%		Row 2: 		4, specifies 4 sides
%		Row 3-6:	x coordinates, going counterclockwise from lower left
%		Row 7-10:	y coordinates, going counterclockwise from lower left
%
% 	These vectors become the columns of the geometry description matrix gd. If
% 	I am using N inclusions, then gd will be a 10 x (N+1) matrix. That's 10
% 	rows for the 10 entries needed to specify each rectangle, and N+1 columns,
% 	i.e. N columns for the N inclusions, and 1 column for the outer boundary
% 	itself. 
%
% 	(3) For the set formula sf: This is a character array describing the set
% 	operations that will be used to construct the final geometry. In this case,
% 	we only need set minus operations, which are encoded by minus signs, and
% 	which are used to indicate that the inclusions should be subtracted from
% 	the original domain.
%
% 	(4) For the name-space matrix ns: Each column of ns represents the name of
% 	the object represented by the data in the corresponding column of the gd
% 	matrix. 
%
%	(5) For example, for a domain with one inclusion, gd will be a 10 x 2
%	matrix: one column for the domain and one column for the inclusion. The sf
%	will be sf = 'BD-P1'. The ns will be:
%			
%			ns = [B P;
%				  D 1];
%
%	where the first column contains the name 'BD' and tells matlab that the
%	data in the first column of gd is 'BD', the second column contains the name
%	'P1', and tells matlab that the second column of gd is 'P1', and that way,
%	from the set formula sf = 'BD-P1', matlab knows to subtract the object
%	represented by the second column of gd from the object represented by the
%	first column of gd. 
%
%	(6) For now, inclusions are generated by creating an array of equally
%	spaced endpoints, which are used to populate gd. For example, for some N_x,
%
%			xVert = linspace(xBounds(1),xBounds(2),2*N_x+2);
%			xVert = xVert(2:2*N_x+1);
%
%	is used to specify endpoints for the inclusions (the second line throws
%	away the nodes that correspond to the boundary of the domain. Certainly
%	we'd like to be able to set the size of the inclusions relative to the rest
%	of the domain. So this will need to change at some point. 
%------------------------------------------------------------------------------%
% METHODS (STATIC)
% vert = boundsToRectangleVertices(x,y)
% Converts bounds x and y to vertices of a rectangular region
%	Vertices are arranged as row vectors in a 4x2 matrix with:
%
%		Row 1: Southwest corner
%		Row 2: Southeast corner
%		Row 3: Northeast corner
%		Row 4: Northwest corner
%	
%	Inputs:
%		x		double (vector), x = [x_1 x_2] the lower and upper x bounds
%		y		double (vector), y = [y_1 y_2] the lower and upper y bounds
%
%	Outputs:
%		vert	double (matrix), vert = [x_1 y_1; x_2 y_1; etc.]
%
%
% col = vertToGeometryDescriptionColumn(vert)
% Converts a matrix of vertices to a column of a geometry description matrix
% 	representing a rectangular region.
%
%	For a region bounded by x = [x_1 x_2], y = [y_1 y_2], vert is of the form
%
%		vert = [x_1 y_1; x_2 y_1; x_2 y_2; x_1 y_1]
%
%	i.e. each row represents a vertex, and the rows cycle through vertices
%	counterclockwise, starting from the southwest.
%
%
% col = boundsToGeometryDescriptionColumn(x,y)
% Converts bounds x and y to a column of a geometry description matrix
%	 representing a rectangular region.
%
%	If x = [x_1 x_2], y = [y_1 y_2] then the coresponding column is
%
%		gd_col = [3 4 x_1 x_2 x_2 x_1 y_1 y_1 y_2 y_2]
%
%	where 3 represents a rectangle, 4 represents that a rectangle has four
%	sides, and the vertices are arranged by cycling through the vertices
%	counterclockwise starting from the southwest, listing the x-coordinates
%	then the y-coordinates.
%
%	Inputs:
%		x		double (vector), x = [x_1 x_2] the lower and upper x bounds
%		y		double (vector), y = [y_1 y_2] the lower and upper y bounds
%
%-----------------------------------------------------------------------------%


	properties
		epsilon
		inclusion
		nInclusions
		effectiveRegion
		meshInclusions
	end

	methods
		function self = Domain2d_punctured(x,y,inc,eps,NameValueArgs)
		
			arguments
				x
				y
				inc
				eps
				NameValueArgs.meshInclusions string = "off"
				NameValueArgs.effectiveRegion string = "Omega_eps"
			end

			% call Domain2d superclass constructor
			self@Domain2d();

			% create decomposed geometry description matrix 
			dl_domain = Domain2d_punctured.dl_domain(x,y);
			if nargin == 2
				dl_Qeps = [];
			else
				dl_Qeps = Domain2d_punctured.dl_Qeps(x,y,inc,eps);
				dl_Qeps = Domain2d_punctured.dl_Qeps_faces(dl_domain,dl_Qeps);
			end
			dl_mat = [dl_domain dl_Qeps];
			
			% set properties related to domain and inclusions
			self.epsilon = eps;
			self.inclusion = inc;
			self.meshInclusions = NameValueArgs.meshInclusions;
			self.effectiveRegion = NameValueArgs.effectiveRegion;

			% generate and store edges
			self.boundary = Boundary2d(dl_mat);

			% set inclusion number
			self.nInclusions = size(dl_mat,2) / 4 - 1;

		end

		
		% GETTERS
		function elemIDs = elements_Omega_eps(self)
			
			mesh = self.mesh.Mesh;
			faceIDs = self.boundary.faceIDs;
			elemIDs = findElements(mesh,"region",Face=faceIDs.Omega_eps);

		end

		function elemIDs = elements_Q_eps(self)

			mesh = self.mesh.Mesh;
			faceIDs = self.boundary.faceIDs;
			elemIDs = findElements(mesh,"region",Face=faceIDs.Q_eps);

		end

		function nodeIDs = nodes_Omega_eps(self)

			mesh = self.mesh.Mesh;
			faceIDs = self.boundary.faceIDs;
			nodeIDs = findNodes(mesh,"region",Face=faceIDs.Omega_eps);

		end

		function nodeIDs = nodes_Q_eps(self)

			mesh = self.mesh.Mesh;
			faceIDs = self.boundary.faceIDs;
			nodeIDs = findNodes(mesh,"region",Face=faceIDs.Q_eps);

		end


		% SETTERS
		function self = setMesh(self,p,base,NameValueArgs)

			arguments
				self
				p double
				base double
				NameValueArgs.effectiveRegion string = self.effectiveRegion
				NameValueArgs.meshInclusions = self.meshInclusions
			end

			% specify whether inclusions are to be meshed
			if strcmp(NameValueArgs.meshInclusions,"on")
				self.meshInclusions = "on";
			else
				self.meshInclusions = "off";
			end

			% if inclusions are to meshed, specify effective region
			if strcmp(self.meshInclusions,"on")
				effectiveRegion = NameValueArgs.effectiveRegion;
				self = self.setEffectiveRegion(effectiveRegion);
			end

			% generate the mesh
			if strcmp(self.meshInclusions,"off")
				dl_mat = self.boundary.dl.mat_reduced;
				self.mesh = Mesh2d(dl_mat,p,base);
			else
				dl_mat = self.boundary.dl.mat;
				self.mesh = Mesh2d(dl_mat,p,base);
			end

			% if BCs already set, distribute BC nodes
			if ~isempty(self.boundary.edges(end).boundaryType)
				self = self.setBoundaryNodes;
			end

			% set effective nodes and elements
			self = self.setEffectiveNodes;
			self = self.setEffectiveElements;

		end

		function self = setEffectiveRegion(self,input)

			% I think this function no longer is necessary?
			% set effective region
			self.effectiveRegion = input;
			if strcmp(input,'Omega')
				self = self.inclusionsON;
			elseif strcmp(input,'Omega_eps')
				self = self.inclusionsOFF;
			end

		end

		function self = inclusionsON(self)

			% I think this function no longer is necessary?
			self.effectiveRegion = 'Omega';
			self.boundary = self.boundary.inclusionsON;
			if ~isempty(self.mesh), self = self.setBoundaryNodes; end

		end

		function self = inclusionsOFF(self)

			% I think this function no longer is necessary?
			self.effectiveRegion = 'Omega_eps';
			self.boundary = self.boundary.inclusionsOFF;
			if ~isempty(self.mesh), self = self.setBoundaryNodes; end

		end

		function self = setEffectiveNodes(self)

			input = self.effectiveRegion;

			% set effective nodes/elements
			if strcmp(input,"Omega_eps")
				self.mesh.effectiveNodes = self.nodes_Omega_eps;

			elseif strcmp(input,'Omega')
				self.mesh.effectiveNodes = [1:self.mesh.nNodes];

			else
				self.mesh.effectiveNodes = self.nodes_Omega_eps;

			end

			% set unused nodes/elements
			self.mesh.unusedNodes = setdiff(1:self.mesh.nNodes, ...
											self.mesh.effectiveNodes);

		end

		function self = setEffectiveElements(self)
			
			input = self.effectiveRegion;

			% set effective nodes/elements
			if strcmp(input,"Omega_eps")
				self.mesh.effectiveElems = self.elements_Omega_eps;

			elseif strcmp(input,'Omega')
				self.mesh.effectiveElems = [1:self.mesh.nElems];

			else
				self.mesh.effectiveElems = self.elements_Omega_eps;
			end

			% set unused nodes/elements
			self.mesh.unusedElems = setdiff(1:self.mesh.nElems, ...
											self.mesh.effectiveElems);

		end


		% Y-LINE
		function self = add_yline(self,varargin)

			self.boundary = self.boundary.add_yline(varargin{:});

		end


		% PLOTTERS
		function h = plot(self,NameValueArgs)

			arguments
				self
				NameValueArgs.NodeLabels string = "off"
				NameValueArgs.NodeFontSize double = 18
				NameValueArgs.ElementLabels string = "off"
			end
			x = NameValueArgs;

			% Plot mesh
			mesh = self.mesh.Mesh;

			% plot all nodes
			h = pdemesh(mesh);

			% capture boundary data to redraw boundaries later
			boundaries = h(2);
			xBdry = boundaries.XData;
			yBdry = boundaries.YData;
			
			% having captured data, clear plot
			clf;

			% plot effective elements
			hold on
			h = pdemesh(mesh.Nodes,mesh.Elements(:,self.mesh.effectiveElems),...
						ElementLabels=x.ElementLabels);

			% Label nodes, optional
			if x.NodeLabels == "on"
				nNodes = size(self.Mesh.Nodes(self.mesh.effectiveNodes),2);	
				xData = self.Mesh.Nodes(1,self.mesh.effectiveNodes);
				yData = self.Mesh.Nodes(2,self.mesh.effectiveNodes);
				for i = 1:nNodes
					text(xData(i),yData(i),strcat('n',num2str(i)), ...
						'FontSize',x.NodeFontSize,'FontWeight','bold');
				end
			end

			% color inclusion elements
			incElem = self.elements_Q_eps;
			k = pdemesh(mesh.Nodes,mesh.Elements(:,incElem));
			if ~isempty(k)
				if strcmp(self.effectiveRegion,'Omega_eps')
					k.Color = [0.7 0.7 0.7];
				else 
					k.Color = [0.3 0.3 1];
				end
			end

			% replot boundary lines
			plot(xBdry,yBdry,"Color","red");
			hold off

		end
	end

	methods (Static)

		function vert = boundsToVertices(x,y)
			
			vert = [x(1) y(1); x(2) y(1); x(2) y(2); x(1) y(2)];

		end
		
		function col = vertToGeometryDescriptionColumn(vert)
			
			col = [3,4,vert(:,1)',vert(:,2)']';

		end

		function col = boundsToGeometryDescriptionColumn(x,y)

			vert = Domain2d_punctured.boundsToVertices(x,y);
			col  = Domain2d_punctured.vertToGeometryDescriptionColumn(vert);
		
		end
	
		
		function gd = getGeometryDescriptionMatrix(xBounds,yBounds,N_x,N_y)

			% initialize storage
			gd = zeros(10,N_x*N_y+1);

			% put boundary rectangle in column 1 of gd
			gd(:,1) = Domain2d_punctured.boundsToGeometryDescriptionColumn(xBounds,yBounds);

			% if nonzero number of inclusions
			if (N_x ~= 0) && (N_y ~= 0)

				% get x and y coordinates of inclusions
				xVert = linspace(xBounds(1),xBounds(2),2*N_x+2);
				yVert = linspace(yBounds(1),yBounds(2),2*N_y+2);
				xVert = xVert(2:2*N_x+1);
				yVert = yVert(2:2*N_y+1);

				% put inclusions in remaining columns of gd
				for i = 0:N_y-1, for j = 0:N_x-1

					% current column number
					col = i*N_x + j + 2;

					% bounds for inclusion
					xPunc = [xVert(2*j+1) xVert(2*j+2)];
					yPunc = [yVert(2*i+1) yVert(2*i+2)];

					% add column to geometry description matrix
					gd(:,col) = Domain2d_punctured.boundsToGeometryDescriptionColumn(xPunc,yPunc);

				end, end
			end
		end

		function ns = getNameSpace(N_x,N_y)

			% if nonzero number of inclusions
			if (N_x ~= 0) && (N_y ~= 0)

				% create ns array
				ns = char('BD');
				for i = 1:N_x*N_y
					punc = char("P" + string(i));
					ns = char(ns,punc);
				end
				ns = ns';

			% else create unpunctured rectangular domain
			else
				ns = char('BD');
				ns = ns';
			end

		end

		function sf = getSetFunction(N_x,N_y)

			% if nonzero number of inclusions
			if (N_x ~= 0) && (N_y ~= 0)

				% create sf
				sf = 'BD-(P1';
				for i = 2:N_x*N_y
					sf = strcat(sf,'+P',int2str(i));
				end
				sf = strcat(sf,')');

			% else create unpunctured rectangular domain
			else
				sf = 'BD';
			end

		end

		function dl_domain = dl_domain(xLim,yLim)

			coord_vector = table2array(combinations(xLim,yLim));
			coord_vector = coord_vector([1 3 4 2],:);
			coord_vector = reshape(coord_vector,[],1);

			Omega = [3;4;coord_vector];

			dl_domain = [decsg(Omega);zeros(3,4)];

		end

		function dl_inclusions = dl_inclusions(xLim,yLim,incMod)

			% get raw decomposed matrix
			dl_inclusions = incMod.decomposedMatrix;

			% discard unnecessary elements
			x_low_check  = dl_inclusions(2:3,:) < xLim(1);
			x_high_check = dl_inclusions(2:3,:) > xLim(2);
			y_low_check  = dl_inclusions(4:5,:) < yLim(1);
			y_high_check = dl_inclusions(4:5,:) > yLim(2);

			mat_check = [x_low_check; x_high_check; y_low_check; y_high_check];
			discard_cols = (sum(mat_check ~= 0));
			discard_cols = reshape(discard_cols,4,[]);
			discard_shapes = sum(discard_cols);
			discard_shapes = repmat(discard_shapes,4,1);
			discard_cols = reshape(discard_shapes,1,[]);
			keep_cols = (discard_cols == 0);

			dl_inclusions = dl_inclusions(:,keep_cols);

		end

		function nCopies = Qeps_nCopies(bound,epsilon)

			nCopies = ceil(abs(diff(bound)) / epsilon);

		end

		function xCopies = Qeps_xCopies(xLim_dom,inc,eps)

			xWidth_Y = inc.Y.xWidth;
			xCopies = ceil(abs(diff(xLim_dom)) / eps / xWidth_Y);

		end

		function yCopies = Qeps_yCopies(yLim_dom,inc,eps)

			yWidth_Y = inc.Y.yWidth;
			yCopies = ceil(abs(diff(yLim_dom)) / eps / yWidth_Y);

		end

		function Qeps_centers = Qeps_centers(xLim,yLim,inc,eps)

			xWidth_Y = inc.Y.xWidth;
			yWidth_Y = inc.Y.yWidth;
			 
			xCopies = Domain2d_punctured.Qeps_xCopies(xLim,inc,eps);
			yCopies = Domain2d_punctured.Qeps_yCopies(yLim,inc,eps);

			xCoord = eps * (xWidth_Y * [0:1:xCopies-1] + inc.center(1));
			yCoord = eps * (yWidth_Y * [0:1:yCopies-1] + inc.center(2));

			Qeps_centers = table2array(combinations(yCoord,xCoord))';
			Qeps_centers = Qeps_centers([2 1],:);

		end

	
		function dl = dl_Qeps(xLim,yLim,inc,eps)
	
			% get centers of inclusions
			combos = Domain2d_punctured.Qeps_centers(xLim,yLim,inc,eps);

			% copy each column of combos four times
			combos = repmat(combos,4,1);
			combos = reshape(combos,2,[]);

			% isolate x- and y-translations
			translate_x = combos(1,:);
			translate_y = combos(2,:);

			% make raw dl matrix
			xCopies = Domain2d_punctured.Qeps_xCopies(xLim,inc,eps);
			yCopies = Domain2d_punctured.Qeps_yCopies(yLim,inc,eps);
			dl = repmat(inc.Q.dl,1,xCopies * yCopies);

			% scale dl matrix
			scaledRows = inc.Q.dl_scaledRows;
			dl(scaledRows,:) = eps * dl(scaledRows,:);

			% translate dl matrix
			xRows = inc.Q.dl_xRows;
			yRows = inc.Q.dl_yRows;
			dl(xRows,:) = dl(xRows,:) + translate_x;
			dl(yRows,:) = dl(yRows,:) + translate_y;

		end

		function dl_Qeps = dl_Qeps_faces(dl_domain,dl_Qeps)

			% enumerate inclusions
			enum = dlObj.enumerateInclusions(dl_Qeps);

			% get largest face number in Omega_eps
			maxID = max(dl_domain(dlObj.leftRow,:));

			% set face IDs for Q_eps
			dl_Qeps(dlObj.leftRow,:) = enum + maxID;

		end


		function orientation = orientation(self,P,Q,R)

			orientation = sign(det([R;Q] - [Q;P]));

		end

		function on_segment = on_segment(self,P,Q,R)


			on_segment = Q(1) <= max(P(1),R(1)) && ... 
						 	Q(1) >= min(P(1),R(1)) && ...
							Q(2) <= max(P(2),R(2)) && ...
							Q(2) >= max(P(2),R(2));

		end

		function intersect = intersect(self,p1,q1,p2,q2)

			o1 = self.orientation(p1,q1,p2);
			o2 = self.orientation(p1,q1,q2);
			o3 = self.orientation(p2,q2,p1);
			o4 = self.orientation(p2,q2,q1);

			% check if segments intersect 
			if o1 ~= o2 && o3 ~= o4
				intersect = 1;

			% check if segments overlap
			elseif o1 == 0 && self.on_segment(p1,p2,q1)
				intersect = 1;
			elseif o2 == 0 && self.on_segment(p1,q2,q1)
				intersect = 1;
			elseif o3 == 0 && self.on_segment(p2,p1,q2)
				intersect = 1;
			elseif o4 == 0 && self.on_segment(p2,q1,q2)
				intersect = 1;

			% else they do not intersect
			else
				intersect = 0;
			end

		end
			

	end

end
