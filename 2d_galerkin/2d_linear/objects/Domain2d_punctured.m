classdef Domain2d_punctured < Domain2d
%PuncturedMesh is a punctured mesh for 2d Galerkin FEM
%	
% mesh = PuncturedMesh(xBounds,yBounds,h,N_x,N_y) generates a quasiuniform
%	triangulated mesh on a rectangle of size xBounds by yBounds with triangles
%	of max diameter h.
%
% Author: Tyler Fara					Date: April 19, 2024
%
%-----------------------------------------------------------------------------%
% Properties
%	xBounds		double (vector), format [x_0,x_1] 
%	yBounds		double (vector), format [y_0,y_1]
%	nInclusions	int (vector), format [N_x, N_y, N_x * N_y]
%	h			double, max triangle diameter
%	mesh		fegeometry object
%
%-----------------------------------------------------------------------------%
% Methods
%	PuncturedMesh(xBounds,yBounds,h,N_x,N_y)
%	Constructor for PuncturedMesh object
% 		inputs
%			xBounds		double (vector), format [x_0,x_1] 
%			yBounds		double (vector), format [y_0,y_1]
%			h			double, max triangle diameter
%			N_x			int, number of inclusions along x-dimension
%			N_y			int, number of inclusions along y-dimension
%		outputs
%			mesh		PuncturedMesh object
%
%	plot(self)
%	Plots mesh
%
%-----------------------------------------------------------------------------%
% Notes
%	(1) The procedure used to generate the mesh:
%		1. Describe domain geometry using constructive solid geometry (CSG)
%		2. Decompose that object using minimal regions
%		3. Create an fegeometry object using that deconstruction 
%		4. Call the fegeometry method called generateMesh to generate the mesh
%
% 	(2) CSG uses simple shapes to build complex shapes through the operations
% 	of set addition, subtraction, and intersection. To implement CSG, matlab
% 	uses objects called a geometry description matrix, a set formula, and a
% 	name-space matrix. The geometry description matrix gd stores numeric
% 	information about the shapes (more description below). The set formula
% 	character array sf stores information about how the shapes interact (more
% 	description below). The name-space matrix ns connects the numeric data in
% 	gd to the interaction data in sf. 
%
%	(3) For the geometry description matrix gd: In this case, the only
% 	shape I will need is rectangles (though, theoretically I could model
% 	inclusions using circles). I specify the rectangles as vectors, where the
% 	convention is: 
%
%		Row 1: 		3, the convention for a rectangle
%		Row 2: 		4, specifies 4 sides
%		Row 3-6:	x coordinates, going counterclockwise from lower left
%		Row 7-10:	y coordinates, going counterclockwise from lower left
%
% 	These vectors become the columns of the geometry description matrix gd. If
% 	I am using N inclusions, then gd will be a 10 x (N+1) matrix. That's 10
% 	rows for the 10 entries needed to specify each rectangle, and N+1 columns,
% 	i.e. N columns for the N inclusions, and 1 column for the outer boundary
% 	itself. 
%
% 	(3) For the set formula sf: This is a character array describing the set
% 	operations that will be used to construct the final geometry. In this case,
% 	we only need set minus operations, which are encoded by minus signs, and
% 	which are used to indicate that the inclusions should be subtracted from
% 	the original domain.
%
% 	(4) For the name-space matrix ns: Each column of ns represents the name of
% 	the object represented by the data in the corresponding column of the gd
% 	matrix. 
%
%	(5) For example, for a domain with one inclusion, gd will be a 10 x 2
%	matrix: one column for the domain and one column for the inclusion. The sf
%	will be sf = 'BD-P1'. The ns will be:
%			
%			ns = [B P;
%				  D 1];
%
%	where the first column contains the name 'BD' and tells matlab that the
%	data in the first column of gd is 'BD', the second column contains the name
%	'P1', and tells matlab that the second column of gd is 'P1', and that way,
%	from the set formula sf = 'BD-P1', matlab knows to subtract the object
%	represented by the second column of gd from the object represented by the
%	first column of gd. 
%
%	(6) For now, inclusions are generated by creating an array of equally
%	spaced endpoints, which are used to populate gd. For example, for some N_x,
%
%			xVert = linspace(xBounds(1),xBounds(2),2*N_x+2);
%			xVert = xVert(2:2*N_x+1);
%
%	is used to specify endpoints for the inclusions (the second line throws
%	away the nodes that correspond to the boundary of the domain. Certainly
%	we'd like to be able to set the size of the inclusions relative to the rest
%	of the domain. So this will need to change at some point. 
%------------------------------------------------------------------------------%
% METHODS (STATIC)
% vert = boundsToRectangleVertices(x,y)
% Converts bounds x and y to vertices of a rectangular region
%	Vertices are arranged as row vectors in a 4x2 matrix with:
%
%		Row 1: Southwest corner
%		Row 2: Southeast corner
%		Row 3: Northeast corner
%		Row 4: Northwest corner
%	
%	Inputs:
%		x		double (vector), x = [x_1 x_2] the lower and upper x bounds
%		y		double (vector), y = [y_1 y_2] the lower and upper y bounds
%
%	Outputs:
%		vert	double (matrix), vert = [x_1 y_1; x_2 y_1; etc.]
%
%
% col = vertToGeometryDescriptionColumn(vert)
% Converts a matrix of vertices to a column of a geometry description matrix
% 	representing a rectangular region.
%
%	For a region bounded by x = [x_1 x_2], y = [y_1 y_2], vert is of the form
%
%		vert = [x_1 y_1; x_2 y_1; x_2 y_2; x_1 y_1]
%
%	i.e. each row represents a vertex, and the rows cycle through vertices
%	counterclockwise, starting from the southwest.
%
%
% col = boundsToGeometryDescriptionColumn(x,y)
% Converts bounds x and y to a column of a geometry description matrix
%	 representing a rectangular region.
%
%	If x = [x_1 x_2], y = [y_1 y_2] then the coresponding column is
%
%		gd_col = [3 4 x_1 x_2 x_2 x_1 y_1 y_1 y_2 y_2]
%
%	where 3 represents a rectangle, 4 represents that a rectangle has four
%	sides, and the vertices are arranged by cycling through the vertices
%	counterclockwise starting from the southwest, listing the x-coordinates
%	then the y-coordinates.
%
%	Inputs:
%		x		double (vector), x = [x_1 x_2] the lower and upper x bounds
%		y		double (vector), y = [y_1 y_2] the lower and upper y bounds
%
%-----------------------------------------------------------------------------%


	properties
		epsilon
		inclusion
		nInclusions
	end

	methods
		function self = Domain2d_punctured(x,y,inc,eps)
		
			% call Domain2d superclass constructor
			self@Domain2d(x,y);

			% create decomposed geometry description matrix 
			dl_domain = Domain2d_punctured.dl_domain(x,y);
			if nargin == 2
				dl_Qeps = [];
			else
				dl_Qeps = Domain2d_punctured.dl_Qeps(x,y,inc,eps);
			end
			dl = [dl_domain dl_Qeps]

			% set properties related to domain and inclusions
			self.epsilon = eps;
			self.inclusion = inc;
			self.dl = dl;

			% generate and store edges
			self.edges = self.setEdgeGeometry_inclusions;
			self.nEdges = self.get_nEdges;

			% set inclusion number
			self.nInclusions = size(self.dl,2) / 4 - 1;

		end

		function edges = setEdgeGeometry_inclusions(self)

			% store variables
			dl = self.dl;

			edges(size(dl,2)) = BoundaryEdge2d_test;
			for j = 1:size(dl,2);

				% create new edge
				vert = reshape(dl(2:5,j),2,2);
				edges(j).vertex1 = vert(1,:);
				edges(j).vertex2 = vert(2,:);
				edges(j).ID = j;

			end

		end

		function self = setEdgeBCTypes(self,boundary)

			edges = self.edges;

			% set outer boundary types
			for i = 1:4
				edges(i).boundaryType = boundary.boundaryTypes{i};
			end

			% set boundary types on inclusions
			incBCTypes = boundary.boundaryTypesInclusions;
			if sum(size(incBCTypes)) == 2
				for i = 5:self.nEdges
					edges(i).boundaryType = incBCTypes;
				end
			else
				for i = 1:self.nInclusions, for j = 1:4
					edges(4*i + j).boundaryType = incBCTypes(i,j);
				end, end
			end

			self.edges = edges;

		end

		function self = setEdgeBCConditions(self,boundary)

			edges = self.edges;

			% set outer boundary types
			for i = 1:4
				edges(i).boundaryCondition = boundary.boundaryConditions{i};
			end

			% set boundary types on inclusions
			incBCCond = boundary.boundaryConditionsInclusions;
			if sum(size(incBCCond)) == 2 || sum(size(incBCCond)) == 3 
				for i = 5:self.nEdges
					edges(i).boundaryCondition = incBCCond;
				end
			else
				for i = 1:self.nInclusions, for j = 1:4
					edges(4*i + j).boundaryCondition = incBCCond(i,j);
				end, end
			end

			self.edges = edges;

		end
	end

	methods (Static)

		function vert = boundsToVertices(x,y)
			
			vert = [x(1) y(1); x(2) y(1); x(2) y(2); x(1) y(2)];

		end
		
		function col = vertToGeometryDescriptionColumn(vert)
			
			col = [3,4,vert(:,1)',vert(:,2)']';

		end

		function col = boundsToGeometryDescriptionColumn(x,y)

			vert = Domain2d_punctured.boundsToVertices(x,y);
			col  = Domain2d_punctured.vertToGeometryDescriptionColumn(vert);
		
		end
	
		
		function gd = getGeometryDescriptionMatrix(xBounds,yBounds,N_x,N_y)

			% initialize storage
			gd = zeros(10,N_x*N_y+1);

			% put boundary rectangle in column 1 of gd
			gd(:,1) = Domain2d_punctured.boundsToGeometryDescriptionColumn(xBounds,yBounds);

			% if nonzero number of inclusions
			if (N_x ~= 0) && (N_y ~= 0)

				% get x and y coordinates of inclusions
				xVert = linspace(xBounds(1),xBounds(2),2*N_x+2);
				yVert = linspace(yBounds(1),yBounds(2),2*N_y+2);
				xVert = xVert(2:2*N_x+1);
				yVert = yVert(2:2*N_y+1);

				% put inclusions in remaining columns of gd
				for i = 0:N_y-1, for j = 0:N_x-1

					% current column number
					col = i*N_x + j + 2;

					% bounds for inclusion
					xPunc = [xVert(2*j+1) xVert(2*j+2)];
					yPunc = [yVert(2*i+1) yVert(2*i+2)];

					% add column to geometry description matrix
					gd(:,col) = Domain2d_punctured.boundsToGeometryDescriptionColumn(xPunc,yPunc);

				end, end
			end
		end

		function ns = getNameSpace(N_x,N_y)

			% if nonzero number of inclusions
			if (N_x ~= 0) && (N_y ~= 0)

				% create ns array
				ns = char('BD');
				for i = 1:N_x*N_y
					punc = char("P" + string(i));
					ns = char(ns,punc);
				end
				ns = ns';

			% else create unpunctured rectangular domain
			else
				ns = char('BD');
				ns = ns';
			end

		end

		function sf = getSetFunction(N_x,N_y)

			% if nonzero number of inclusions
			if (N_x ~= 0) && (N_y ~= 0)

				% create sf
				sf = 'BD-(P1';
				for i = 2:N_x*N_y
					sf = strcat(sf,'+P',int2str(i));
				end
				sf = strcat(sf,')');

			% else create unpunctured rectangular domain
			else
				sf = 'BD';
			end

		end

		function dl_domain = dl_domain(xLim,yLim)

			coord_vector = table2array(combinations(xLim,yLim));
			coord_vector = coord_vector([1 3 4 2],:);
			coord_vector = reshape(coord_vector,[],1);

			Omega = [3;4;coord_vector];

			dl_domain = [decsg(Omega);zeros(3,4)];

		end

		function dl_inclusions = dl_inclusions(xLim,yLim,incMod)

			% get raw decomposed matrix
			dl_inclusions = incMod.decomposedMatrix;

			% discard unnecessary elements
			x_low_check  = dl_inclusions(2:3,:) < xLim(1);
			x_high_check = dl_inclusions(2:3,:) > xLim(2);
			y_low_check  = dl_inclusions(4:5,:) < yLim(1);
			y_high_check = dl_inclusions(4:5,:) > yLim(2);

			mat_check = [x_low_check; x_high_check; y_low_check; y_high_check];
			discard_cols = (sum(mat_check ~= 0));
			discard_cols = reshape(discard_cols,4,[]);
			discard_shapes = sum(discard_cols);
			discard_shapes = repmat(discard_shapes,4,1);
			discard_cols = reshape(discard_shapes,1,[]);
			keep_cols = (discard_cols == 0);

			dl_inclusions = dl_inclusions(:,keep_cols);

		end

		function nCopies = Qeps_nCopies(bound,epsilon)

			nCopies = ceil(abs(diff(bound)) / epsilon);

		end

		function xCopies = Qeps_xCopies(xLim_dom,inc,eps)

			xWidth_Y = inc.Y.xWidth;
			xCopies = ceil(abs(diff(xLim_dom)) / eps / xWidth_Y);

		end

		function yCopies = Qeps_yCopies(yLim_dom,inc,eps)

			yWidth_Y = inc.Y.yWidth;
			yCopies = ceil(abs(diff(yLim_dom)) / eps / yWidth_Y);

		end

		function Qeps_centers = Qeps_centers(xLim,yLim,inc,eps)

			xWidth_Y = inc.Y.xWidth;
			yWidth_Y = inc.Y.yWidth;
			 
			xCopies = Domain2d_punctured.Qeps_xCopies(xLim,inc,eps);
			yCopies = Domain2d_punctured.Qeps_yCopies(yLim,inc,eps);

			xCoord = eps * (xWidth_Y * [0:1:xCopies-1] + inc.center(1));
			yCoord = eps * (yWidth_Y * [0:1:yCopies-1] + inc.center(2));

			Qeps_centers = table2array(combinations(yCoord,xCoord))';
			Qeps_centers = Qeps_centers([2 1],:);

		end

	
		function dl = dl_Qeps(xLim,yLim,inc,eps)
	
			% get centers of inclusions
			combos = Domain2d_punctured.Qeps_centers(xLim,yLim,inc,eps);

			% copy each column of combos four times
			combos = repmat(combos,4,1);
			combos = reshape(combos,2,[]);

			% isolate x- and y-translations
			translate_x = combos(1,:);
			translate_y = combos(2,:);

			% make raw dl matrix
			xCopies = Domain2d_punctured.Qeps_xCopies(xLim,inc,eps);
			yCopies = Domain2d_punctured.Qeps_yCopies(yLim,inc,eps);
			dl = repmat(inc.Q.dl,1,xCopies * yCopies);

			% scale dl matrix
			scaledRows = inc.Q.dl_scaledRows;
			dl(scaledRows,:) = eps * dl(scaledRows,:);

			% translate dl matrix
			xRows = inc.Q.dl_xRows;
			yRows = inc.Q.dl_yRows;
			dl(xRows,:) = dl(xRows,:) + translate_x;
			dl(yRows,:) = dl(yRows,:) + translate_y;

		end

		function orientation = orientation(self,P,Q,R)

			orientation = sign(det([R;Q] - [Q;P]));

		end

		function on_segment = on_segment(self,P,Q,R)


			on_segment = Q(1) <= max(P(1),R(1)) && ... 
						 	Q(1) >= min(P(1),R(1)) && ...
							Q(2) <= max(P(2),R(2)) && ...
							Q(2) >= max(P(2),R(2));

		end

		function intersect = intersect(self,p1,q1,p2,q2)

			o1 = self.orientation(p1,q1,p2);
			o2 = self.orientation(p1,q1,q2);
			o3 = self.orientation(p2,q2,p1);
			o4 = self.orientation(p2,q2,q1);

			% check if segments intersect 
			if o1 ~= o2 && o3 ~= o4
				intersect = 1;

			% check if segments overlap
			elseif o1 == 0 && self.on_segment(p1,p2,q1)
				intersect = 1;
			elseif o2 == 0 && self.on_segment(p1,q2,q1)
				intersect = 1;
			elseif o3 == 0 && self.on_segment(p2,p1,q2)
				intersect = 1;
			elseif o4 == 0 && self.on_segment(p2,q1,q2)
				intersect = 1;

			% else they do not intersect
			else
				intersect = 0;
			end

		end
			

	end

end
